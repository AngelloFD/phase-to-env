const core = require('@actions/core');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchSecretsWithRetry(url, params, headers, retries = 0) {
  try {
    return await axios.get(url, { params, headers });
  } catch (error) {
    if (retries < MAX_RETRIES) {
      const delay = RETRY_DELAY_MS * Math.pow(2, retries);
      console.warn(`Request failed. Retrying in ${delay}ms... (Attempt ${retries + 1}/${MAX_RETRIES})`);
      await sleep(delay);
      return fetchSecretsWithRetry(url, params, headers, retries + 1);
    }
    throw error;
  }
}

async function run() {
  try {
    const appId = core.getInput('APP_ID', { required: true });
    const envName = core.getInput('ENV_NAME', { required: true });
    const token = core.getInput('SERVICE_TOKEN', { required: true });
    const host = core.getInput('HOST', { required: true });
    const excludeSecretsInput = core.getInput('EXCLUDE_SECRETS') || '';
    const secretFilePath = core.getInput('SECRET_FILE_PATH') || '.env';
    const exportEnvVars = core.getInput('EXPORT_ENV_VARS') === 'true';
    
    const excludedSecretPatterns = excludeSecretsInput
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0)
      .map(pattern => {
        try {
          const escapedPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
          const regexStr = `^${escapedPattern.replace(/\*/g, '.*')}$`;
          return new RegExp(regexStr);
        } catch (e) {
          console.warn(`Invalid pattern ignored: ${pattern}`);
          return null;
        }
      })
      .filter(regex => regex !== null);

    const baseUrl = host.replace(/\/$/, '');
    
    let apiUrl;
    if (baseUrl === 'https://api.phase.dev') {
      apiUrl = `${baseUrl}/v1/secrets`;
    } else if (baseUrl.includes('/service/public')) {
      apiUrl = `${baseUrl}/v1/secrets/`;
    } else {
      apiUrl = `${baseUrl}/service/public/v1/secrets/`;
    }

    console.log(`Fetching secrets for App ID: ${appId}, Environment: ${envName}, Host: ${baseUrl}...`);

    const response = await fetchSecretsWithRetry(apiUrl, {
      app_id: appId,
      env: envName
    }, {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });

    let secrets = [];
    
    if (Array.isArray(response.data)) {
      secrets = response.data;
    } else if (response.data && Array.isArray(response.data.secrets)) {
      secrets = response.data.secrets;
    } else {
      console.log('Response received:', JSON.stringify(response.data, null, 2));
      throw new Error('Unexpected response format from Phase API');
    }

    const validSecrets = secrets.filter(s => s.key && s.value);
    const includedSecrets = [];
    const excludedSecretsList = [];

    for (const secret of validSecrets) {
      if (excludedSecretPatterns.some(regex => regex.test(secret.key))) {
        excludedSecretsList.push(secret.key);
      } else {
        // Security: Mask the secret value in logs
        core.setSecret(secret.value);
        includedSecrets.push(secret);

        if (exportEnvVars) {
          core.exportVariable(secret.key, secret.value);
        }
      }
    }

    const runNumber = process.env.GITHUB_RUN_NUMBER || 'local';
    const header = `# Autogenerated by Phase Secrets Action on ${new Date().toISOString()} (Run: ${runNumber})\n`;
    const envContent = header + includedSecrets
      .map(s => {
        const cleanValue = s.value.replace(/[\r\n]+/g, '');
        let finalValue = cleanValue;
        
        if (cleanValue.startsWith('"') || cleanValue.startsWith("'")) {
          finalValue = `"${cleanValue.replace(/"/g, '\\"')}"`;
        }
        
        return `${s.key}=${finalValue}`;
      })
      .join('\n');

    const dir = path.dirname(secretFilePath);
    if (dir && dir !== '.' && dir !== '..') {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(secretFilePath, envContent);
    
    console.log(`${secretFilePath} file created successfully.`);
    console.log(`Included secrets: ${includedSecrets.length}`);
    console.log(`Excluded secrets: ${excludedSecretsList.length}`);
    if (excludedSecretsList.length > 0) {
      console.log(`Excluded list: ${excludedSecretsList.join(', ')}`);
    }

  } catch (error) {
    console.error('Error fetching secrets:', error.response ? error.response.data : error.message);
    core.setFailed(error.message);
  }
}

run();
